"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TwitterApiRateLimitMemoryStore = void 0;
class TwitterApiRateLimitMemoryStore {
    constructor() {
        this.cache = {};
    }
    get(args) {
        var _a, _b;
        if (args.method) {
            return (_b = (_a = this.cache[args.method]) === null || _a === void 0 ? void 0 : _a[args.endpoint]) === null || _b === void 0 ? void 0 : _b.rateLimit;
        }
        else {
            for (const methodUrls of Object.values(this.cache)) {
                if (args.endpoint in methodUrls) {
                    return methodUrls[args.endpoint].rateLimit;
                }
            }
            // otherwise: not found
        }
    }
    set(args) {
        const method = args.method;
        const endpoint = args.endpoint;
        if (!this.cache[method]) {
            this.cache[method] = {};
        }
        // Delete possible existing item
        this.delete(method, endpoint);
        const timeUntilResetAndNow = (args.rateLimit.reset * 1000) - Date.now();
        const normalizedTime = timeUntilResetAndNow < 0 ? 0 : timeUntilResetAndNow;
        // Item is deleted automatically when {args.rateLimit.reset} happens
        this.cache[method][endpoint] = {
            rateLimit: args.rateLimit,
            timeout: setTimeout(() => {
                this.delete(method, endpoint);
            }, normalizedTime),
        };
        // Don't make timeout block event loop
        this.cache[method][endpoint].timeout.unref();
    }
    delete(method, endpoint) {
        var _a;
        const item = (_a = this.cache[method]) === null || _a === void 0 ? void 0 : _a[endpoint];
        if (item) {
            clearTimeout(item.timeout);
            delete this.cache[method][endpoint];
        }
    }
}
exports.TwitterApiRateLimitMemoryStore = TwitterApiRateLimitMemoryStore;
